#include <bits/stdc++.h>
using namespace std;
const int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
vector<int> xs, ys;
void add(vector<int>& p) {
    int x = p[0], y = p[1];
    for (int i = -1; i != 2; ++i){
        if (x + i >= 0) xs.push_back(x + i);
        if (y + i >= 0) ys.push_back(y + i);
    }
}
void update(vector<int>& p) {
    p[0] = lower_bound(xs.begin(), xs.end(), p[0]) - xs.begin();
    p[1] = lower_bound(ys.begin(), ys.end(), p[1]) - ys.begin();
}
bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
    add(source), add(target);
    for (auto& v: blocked) add(v);

    sort(xs.begin(), xs.end());
    sort(ys.begin(), ys.end());
    xs.erase(unique(xs.begin(), xs.end()), xs.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());

    int W = xs.size(), H = ys.size();
    bool vis[W][H];
    memset(vis, 0, sizeof(vis));

    update(source), update(target);
    for (auto& v: blocked) {
        update(v);
        vis[v[0]][v[1]] = true;
    }
    int sx = source[0], sy = source[1], tx = target[0], ty = target[1];

    typedef pair<int, int> P;
    queue<P> que;
    que.push({sx, sy});
    while (!que.empty()) {
        P p = que.front(); que.pop();
        int x = p.first, y = p.second;
        if (vis[x][y]) continue;
        vis[x][y] = true;
        for (int i = 0; i != 4; ++i) {
            int dx = dir[i][0], dy = dir[i][1];
            int nx = x + dx, ny = y + dy;
            if (nx == tx && ny == ty) return true;
            if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;
            que.push({nx, ny});
        }
    }
    return false;
}

int main()
{
    // vector<vector<int>> blocked{{0, 1}, {1, 0}};
    // vector<int> source{0, 0};
    // vector<int> target{0, 2};
    // vector<vector<int>> blocked{{629173,232687},{695376,426436},{164553,460497},{956954,310238},{322182,515846},{847558,240198},{792551,770487},{4146,573081},{397773,751953},{899296,153588},{731578,860293},{616566,678204},{731801,813001},{68606,163479},{839668,109780},{57126,967537}};
    // vector<int> source{603201,575992};
    // vector<int> target{765501,302566};
    // vector<vector<int>> blocked{};
    // vector<int> source{0, 0};
    // vector<int> target{999999, 999999};
    vector<vector<int>> blocked{{100059,100063},{100060,100064},{100061,100065},{100062,100066},{100063,100067},{100064,100068},{100065,100069},{100066,100070},{100067,100071},{100068,100072},{100069,100073},{100070,100074},{100071,100075},{100072,100076},{100073,100077},{100074,100078},{100075,100079},{100076,100080},{100077,100081},{100078,100082},{100079,100083},{100080,100082},{100081,100081},{100082,100080},{100083,100079},{100084,100078},{100085,100077},{100086,100076},{100087,100075},{100088,100074},{100089,100073},{100090,100072},{100091,100071},{100092,100070},{100093,100069},{100094,100068},{100095,100067},{100096,100066},{100097,100065},{100098,100064},{100099,100063},{100098,100062},{100097,100061},{100096,100060},{100095,100059},{100094,100058},{100093,100057},{100092,100056},{100091,100055},{100090,100054},{100089,100053},{100088,100052},{100087,100051},{100086,100050},{100085,100049},{100084,100048},{100083,100047},{100082,100046},{100081,100045},{100080,100044},{100079,100043},{100078,100044},{100077,100045},{100076,100046},{100075,100047},{100074,100048},{100073,100049},{100072,100050},{100071,100051},{100070,100052},{100069,100053},{100068,100054},{100067,100055},{100066,100056},{100065,100057},{100064,100058},{100063,100059},{100062,100060},{100061,100061},{100060,100062}};
    vector<int> source{100079,100063};
    vector<int> target{999948,999967};
    cout << isEscapePossible(blocked, source, target) << endl;
    return 0;
}
/*
[[629173,232687],[695376,426436],[164553,460497],[956954,310238],[322182,515846],[847558,240198],[792551,770487],[4146,573081],[397773,751953],[899296,153588],[731578,860293],[616566,678204],[731801,813001],[68606,163479],[839668,109780],[57126,967537]]
[603201,575992]
[765501,302566]

[[100059,100063],[100060,100064],[100061,100065],[100062,100066],[100063,100067],[100064,100068],[100065,100069],[100066,100070],[100067,100071],[100068,100072],[100069,100073],[100070,100074],[100071,100075],[100072,100076],[100073,100077],[100074,100078],[100075,100079],[100076,100080],[100077,100081],[100078,100082],[100079,100083],[100080,100082],[100081,100081],[100082,100080],[100083,100079],[100084,100078],[100085,100077],[100086,100076],[100087,100075],[100088,100074],[100089,100073],[100090,100072],[100091,100071],[100092,100070],[100093,100069],[100094,100068],[100095,100067],[100096,100066],[100097,100065],[100098,100064],[100099,100063],[100098,100062],[100097,100061],[100096,100060],[100095,100059],[100094,100058],[100093,100057],[100092,100056],[100091,100055],[100090,100054],[100089,100053],[100088,100052],[100087,100051],[100086,100050],[100085,100049],[100084,100048],[100083,100047],[100082,100046],[100081,100045],[100080,100044],[100079,100043],[100078,100044],[100077,100045],[100076,100046],[100075,100047],[100074,100048],[100073,100049],[100072,100050],[100071,100051],[100070,100052],[100069,100053],[100068,100054],[100067,100055],[100066,100056],[100065,100057],[100064,100058],[100063,100059],[100062,100060],[100061,100061],[100060,100062]]
[100079,100063]
[999948,999967]

*/