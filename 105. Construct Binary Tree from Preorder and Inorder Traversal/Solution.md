# [leetcode 105: 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/constr$u$ct-binary-tree-from-preorder-and-inorder-traversal/)

对于前序遍历中的任意两个连续节点 $u$ 和 $v$, 根据前序遍历的流程，我们可以知道 $u$ 和 $v$ 只有两种可能的关系：

 - $v$ 是 $u$ 的左儿子。这是因为在遍历到 $v$ 之后，下一个遍历的节点就是 $u$ 的左儿子，即 $v$；
 - $u$ 没有左儿子，则 $v$ 是 $u$ 的某个祖先节点（或者 $u$ 本身）的右儿子。如果 $u$ 有右儿子，那么下一个遍历的节点就是 $u$ 的右儿子。如果 $u$ 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 $u$ 不在其的右儿子的子树中）的节点 $u_a$, 那么 $v$ 就是 $u_a$ 的右儿子。

我们遍历前序序列，用一个栈 `stack` 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 `index` 指向中序序列的某个位置，初始值为 `0`。`index` 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的。
```
        3
       / \
      9  20
     /  /  \
    8  15   7
   / \
  5  10
 /
4
先序序列: [3, 9, 8, 5, 4, 10, 20, 15, 7]
中序序列: [4, 5, 8, 10, 9, 3, 15, 20, 7]
```
对于这棵树，我们有 `index[{3,9,8,5,4}]->4` 因为这些节点不断往左走最后会到达 `4`, 但是注意 `index` 内实际存储的值是 `0`, 因为 `index` 中存储的是位置。同理有 `index[{10}]->10`, `index[{20, 15}]->15`, `index[{7}]->7`, 注意到我列出 `index` 是按照先序序列的顺序，因为我们正是通过遍历先序序列来得到重建树的。

定义好 `stack` 和 `index` 后，我现在开始描述实际算法，并证明其正确性。

- 对于上例，初始时我们有 `stack=[3]`, `index->4`, 我们不断遍历先序序列，如果发现栈顶元素仍不等于最左端的元素 `index->`，那就将当前节点直接当成左节点连到栈顶的元素上，然后将该节点压入栈中。这样重复多次，我们有
  - `stack = [3, 9, 8, 5, 4]`
  - `index -> 4`
  - 此时先序序列为 `[`~~`3, 9, 8, 5, 4,`~~` 10, 20, 15, 7]`
  - 建的树为:
```
        3
       /
      9
     /
    8
   /
  5
 /
4
```
- 我们遍历到 `10`，这时情况就不一样了。我们发现 `index` 恰好指向当前的栈顶节点 `4`，也就是说 `4` 没有左儿子，那么 `10` 必须为栈中某个节点的右儿子，接下来我们要找到这个节点。

我们知道栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，且栈中的任意两个相邻的节点，前者都是后者的某个祖先。即后者一定是前者左儿子的子树中的节点。中序遍历的顺序是 `左儿子->父节点->右儿子`，但是栈中的顺序是 `父节点->左儿子`，因此我们可以不断从栈弹出元素来找到右儿子。

我们把 `index` 不断向右移动，并与栈顶元素进行比较。如果 `index` 对应的元素恰好等于栈顶元素，那么说明我们在中序遍历中找到的是 `父节点` 或者 `左儿子`，所以将 `index` 增加 `1` 并弹出栈顶节点，直到 `index` 对应的元素不等于栈顶节点，此时说明 `index` 指向的元素是 `右儿子`, 而之前栈顶弹出的是 `父节点`，而这个 `父节点` 正是我们要找的那个节点。

- 按照这样的过程，我们的例子中弹出的最后一个节点将会是 `8`，也就是 `10` 的父节点，我们将 `10` 作为 `8` 的右儿子，然后再将 `10` 压入栈中。

- 此时我们有
  - `stack = [3, 9, 10]`
  - `index -> 10`
  - 先序序列为 `[`~~`3, 9, 8, 5, 4, 10,`~~` 20, 15, 7]`
  - 中序序列为 `[`~~`4, 5, 8,`~~` 10, 9, 3, 15, 20, 7]`.
  - 建的树为:
```
        3
       /
      9
     /
    8
   / \
  5  10
 /
4
```
- 我们遍历到 `20`。同理，`index` 恰好指向当前栈顶节点 `10`，那么我们会依次从栈顶弹出 `10`, `9` 和 `3`, 并且将 `index` 向右移动了三次。我们将 `20` 作为最后弹出的节点 `3` 的右儿子，然后将 `20` 入栈。

  - `stack = [20]`
  - `index -> 15`
- 我们遍历 `15`，将 `15` 作为栈顶节点 `20` 的左儿子，然后将 `15` 入栈。

  - `stack = [20, 15]`
  - `index -> inorder[6] = 15`
- 我们遍历 `7`, `index` 恰好指向当前栈顶节点 `15`，那么我们会依次从栈顶弹出 `15` 和 `20`，并且将 `index` 向右移动了两次。我们将 `7` 作为最后弹出的节点 `20` 的右儿子，然后将 `7` 入栈。
  - `stack = [7]`
  - `index -> inorder[8] = 7`
  
此时遍历结束，我们就构造出了正确的二叉树。

__算法__

我们归纳出上述例子中的算法流程：

- 我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；

- 我们依次枚举前序遍历中除了第一个节点以外的每个节点，此时有两种情况：
  1. 如果 `index` 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 `index` 直至不相同，然后将当前节点作为最后一个弹出的节点的右儿子。
  2. 如果 `index` 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子。

- 无论是哪一种情况，我们最后都将当前节点入栈。
